在修改parser的时候发现一段移植性差的代码：align_n有个地方是计算地址差的，pc+1-code，实际上pc不是指向code附近，而是指向maincode附近，code和maincode由于定义在一起（中间隔着一个指针变量），所以地址是连续的，

parser好像跑通了，不过运行还是失败，我用最简单的print测试，但print无法从栈中读出，实际读出为nil。。。差不多胜利在望了（大概） 

vc6好像对于含有“井line”的文件会无法下断点（井line的文件可能不存在），需要用替换工具找到所有地方注释掉，如果漏了的话试下在井和line之间填几个空格试试，或者查找所有line的行。。。 

获取sizeof值的最快方法：创建一个c工程，调试，watch，输入sizeof(long)，回车 

lexer终于调通了，我的方法是在lexer的代码里面找三个比较典型的位置下断点，然后观察yyt相对于yycrank的偏移变化（好累），对比就能发现执行路径的区别。另一个地方是循环开头有一段调试代码可以打印出状态值（应该就是yystate的偏移量）。目前还是运行失败，卡在parser动作上（移植写得不好），不过parser本身可能也有一些问题

现在lexer可以正常工作了，但是解释失败。。。发现byacc生成代码里面有些地方数组越界了，然而用vc6跑没问题，已经没什么可怕的了（我严重怀疑在数组后面定义另一个数组会避免向后越界错误，但那些负数下标的向前越界依然无事是怎么回事）





我的Lua 1.0 csharp移植版终于可以跑最简单的hello程序了，如图。最后我做了一些bug修改使栈的状态正常：我把code和maincode指向同一个数组，原版是两个声明在一起的数组，理论上是连续内存，不过csharp不能这样写。另外我对yytext做了程序上的限制，使其无法修改，原版是一个固定指针。print函数的栈位置是在编译期（parser阶段）通过lua_findsymbol计算出来的，所以指令集中只会看到PUSHGLOBAL和一个整数参数。还有，PrintCode打印出来的是很长的一段指令，其实是因为实际生成指令是从maincode指针开始，而非从code指针开始，所以开头有大概4*1024+256+4个空字节


----------------------------

TODO:
unchecked
