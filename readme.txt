在修改parser的时候发现一段移植性差的代码：align_n有个地方是计算地址差的，pc+1-code，实际上pc不是指向code附近，而是指向maincode附近，code和maincode由于定义在一起（中间隔着一个指针变量），所以地址是连续的，

parser好像跑通了，不过运行还是失败，我用最简单的print测试，但print无法从栈中读出，实际读出为nil。。。差不多胜利在望了（大概） 

vc6好像对于含有“井line”的文件会无法下断点（井line的文件可能不存在），需要用替换工具找到所有地方注释掉，如果漏了的话试下在井和line之间填几个空格试试，或者查找所有line的行。。。 

获取sizeof值的最快方法：创建一个c工程，调试，watch，输入sizeof(long)，回车 

lexer终于调通了，我的方法是在lexer的代码里面找三个比较典型的位置下断点，然后观察yyt相对于yycrank的偏移变化（好累），对比就能发现执行路径的区别。另一个地方是循环开头有一段调试代码可以打印出状态值（应该就是yystate的偏移量）。目前还是运行失败，卡在parser动作上（移植写得不好），不过parser本身可能也有一些问题

现在lexer可以正常工作了，但是解释失败。。。发现byacc生成代码里面有些地方数组越界了，然而用vc6跑没问题，已经没什么可怕的了（我严重怀疑在数组后面定义另一个数组会避免向后越界错误，但那些负数下标的向前越界依然无事是怎么回事）

